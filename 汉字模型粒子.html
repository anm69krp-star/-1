<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 行书汉字粒子交互系统</title>
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Ma Shan Zheng', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 160px;
            height: 120px;
            z-index: 2;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            overflow: hidden;
            transform: scaleX(-1);
            opacity: 0.8;
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            z-index: 10;
            pointer-events: none;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.umd.min.js"></script>
</head>
<body>

    <div id="loading">
        <h2>AI 汉字粒子系统启动中...</h2>
        <p>正在加载行书字体与视觉引擎</p>
    </div>

    <div id="video-container">
        <video id="input-video"></video>
    </div>
    <div id="canvas-container"></div>

<script>
/**
 * 配置与状态
 */
let scene, camera, renderer, particles, geometry, material;
const PARTICLE_COUNT = 30000;
const posArray = new Float32Array(PARTICLE_COUNT * 3);
const targetArray = new Float32Array(PARTICLE_COUNT * 3);

const state = {
    shape: '汉字',
    inputText: '禅', // 默认汉字
    baseColor: '#00ccff',     
    shrinkColor: '#ff0055',   
    expandColor: '#ffcc00',   
    pointSize: 0.12,
    handDistance: 1.0,
    lerpSpeed: 0.07,   
    rotationSpeed: 0.0015
};

const shapesMap = {
    '汉字': 'text',
    '爱心': 'heart',
    '星球': 'sphere',
    '土星': 'saturn',
    '打坐(佛像)': 'buddha',
    '花朵': 'flower'
};

// 离屏 Canvas 用于文字采样
const textCanvas = document.createElement('canvas');
const textCtx = textCanvas.getContext('2d');
textCanvas.width = 128;
textCanvas.height = 128;

/**
 * 核心：将汉字转换为坐标点
 */
function getTextPoints(text) {
    const points = [];
    textCtx.clearRect(0, 0, 128, 128);
    // 使用引入的行书字体
    textCtx.font = "90px 'Ma Shan Zheng'";
    textCtx.fillStyle = "white";
    textCtx.textAlign = "center";
    textCtx.textBaseline = "middle";
    textCtx.fillText(text, 64, 64);

    const imageData = textCtx.getImageData(0, 0, 128, 128).data;
    
    // 扫描像素
    for (let y = 0; y < 128; y += 1) {
        for (let x = 0; x < 128; x += 1) {
            const alpha = imageData[(y * 128 + x) * 4 + 3];
            if (alpha > 128) {
                // 将 0-128 映射到 3D 空间坐标 (-15 到 15)
                points.push({
                    x: (x - 64) * 0.3,
                    y: (64 - y) * 0.3,
                    z: 0
                });
            }
        }
    }
    return points;
}

/**
 * 1. 初始化场景
 */
function initThree() {
    const container = document.getElementById('canvas-container');
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.012);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 30); 

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    material = new THREE.PointsMaterial({
        size: state.pointSize,
        color: state.baseColor,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });

    geometry = new THREE.BufferGeometry();
    for(let i = 0; i < PARTICLE_COUNT * 3; i++) {
        posArray[i] = (Math.random() - 0.5) * 100;
    }
    geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
    
    particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // 初始生成
    setTimeout(() => generateShape('text'), 1000); // 等待字体加载
    window.addEventListener('resize', onWindowResize);
}

/**
 * 2. 形状生成逻辑
 */
function generateShape(type) {
    // 汉字需要正面面对摄像机，重置旋转
    particles.rotation.set(0, 0, 0);

    let points = [];
    if (type === 'text') {
        points = getTextPoints(state.inputText);
    }

    for (let i = 0; i < PARTICLE_COUNT; i++) {
        let x, y, z;
        const i3 = i * 3;
        
        if (type === 'text' && points.length > 0) {
            // 从采样点中循环选择
            const p = points[i % points.length];
            // 增加一点厚度和随机偏移，使汉字看起来更生动
            x = p.x + (Math.random() - 0.5) * 0.5;
            y = p.y + (Math.random() - 0.5) * 0.5;
            z = (Math.random() - 0.5) * 2; 
        } 
        else if (type === 'sphere') {
            const r = 12;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            x = r * Math.sin(phi) * Math.cos(theta);
            y = r * Math.cos(phi); 
            z = r * Math.sin(phi) * Math.sin(theta);
        } 
        else if (type === 'heart') {
            const t = Math.random() * Math.PI * 2;
            const r = Math.pow(Math.random(), 0.3); 
            x = 16 * Math.pow(Math.sin(t), 3);
            y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            z = (Math.random() - 0.5) * 5; 
            x *= r * 0.8; y *= r * 0.8; z *= r * 0.8;
        }
        else if (type === 'saturn') {
            const isRing = Math.random() > 0.5;
            if (!isRing) {
                const r = 7;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.cos(phi);
                z = r * Math.sin(phi) * Math.sin(theta);
            } else {
                const angle = Math.random() * Math.PI * 2;
                const dist = 10 + Math.random() * 6; 
                x = Math.cos(angle) * dist;
                y = (Math.random() - 0.5) * 0.5;
                z = Math.sin(angle) * dist;
            }
        }
        else if (type === 'flower') {
            const u = Math.random() * Math.PI * 2;
            const v = Math.random() * Math.PI;
            const r = 8 + 4 * Math.cos(5 * u);
            x = r * Math.sin(v) * Math.cos(u);
            y = r * Math.sin(v) * Math.sin(u);
            z = (Math.cos(v) * 2);
        }
        else if (type === 'buddha') {
            const rVal = Math.random();
            if (rVal < 0.2) {
                const r = 2.5; const theta = Math.random() * Math.PI * 2; const phi = Math.acos((Math.random() * 2) - 1);
                x = r * Math.sin(phi) * Math.cos(theta); y = r * Math.cos(phi) + 7; z = r * Math.sin(phi) * Math.sin(theta);
            } else if (rVal < 0.6) {
                const h = (Math.random()) * 8; const rBase = 4.5 * (1 - h/12); const angle = Math.random() * Math.PI * 2; const rad = Math.sqrt(Math.random()) * rBase;
                x = Math.cos(angle) * rad; y = h - 1; z = Math.sin(angle) * rad;
            } else {
                const angle = Math.random() * Math.PI * 2; const rad = Math.sqrt(Math.random()) * 7.5;
                x = Math.cos(angle) * rad; y = (Math.random() - 0.5) * 2 - 2; z = Math.sin(angle) * rad * 0.8;
            }
        }

        targetArray[i3] = x;
        targetArray[i3 + 1] = y;
        targetArray[i3 + 2] = z;
    }
}

/**
 * 3. AI 手势识别
 */
function initMediaPipe() {
    const videoElement = document.getElementById('input-video');
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});

    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
    hands.onResults(results => {
        document.getElementById('loading').style.display = 'none';
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            const dist = Math.sqrt(Math.pow(landmarks[4].x - landmarks[8].x, 2) + Math.pow(landmarks[4].y - landmarks[8].y, 2));
            let target = THREE.MathUtils.mapLinear(dist, 0.03, 0.25, 0.3, 3.5);
            state.handDistance += (target - state.handDistance) * 0.15;
        } else {
            state.handDistance += (1.0 - state.handDistance) * 0.05;
        }
    });

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320, height: 240
    });
    cameraUtils.start();
}

/**
 * 4. 控制面板
 */
function initGUI() {
    const gui = new lil.GUI({ title: '汉字粒子交互面板' });
    
    // 汉字输入交互
    gui.add(state, 'inputText').name('输入汉字').onFinishChange(val => {
        if(state.shape === '汉字') generateShape('text');
    });

    gui.add(state, 'shape', Object.keys(shapesMap)).name('切换模型').onChange(val => {
        generateShape(shapesMap[val]);
    });
    
    const colorFolder = gui.addFolder('交互色彩');
    colorFolder.addColor(state, 'baseColor').name('常态色');
    colorFolder.addColor(state, 'shrinkColor').name('聚拢色');
    colorFolder.addColor(state, 'expandColor').name('炸裂色');

    gui.add(state, 'pointSize', 0.05, 0.4).name('点大小').onChange(val => material.size = val);
    gui.add(state, 'rotationSpeed', 0, 0.01).name('旋转速度');
}

/**
 * 5. 渲染循环
 */
const c1 = new THREE.Color();
const c2 = new THREE.Color();

function animate() {
    requestAnimationFrame(animate);

    const positions = particles.geometry.attributes.position.array;
    
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        // 目标位置叠加手势缩放
        const tx = targetArray[i3] * state.handDistance;
        const ty = targetArray[i3+1] * state.handDistance;
        const tz = targetArray[i3+2] * state.handDistance;

        positions[i3] += (tx - positions[i3]) * state.lerpSpeed;
        positions[i3+1] += (ty - positions[i3+1]) * state.lerpSpeed;
        positions[i3+2] += (tz - positions[i3+2]) * state.lerpSpeed;
    }
    particles.geometry.attributes.position.needsUpdate = true;

    // 颜色插值逻辑
    if (state.handDistance < 1.0) {
        const t = THREE.MathUtils.lerp(0, 1, (1.0 - state.handDistance) / 0.7);
        material.color.lerpColors(c1.set(state.baseColor), c2.set(state.shrinkColor), t);
    } else {
        const t = THREE.MathUtils.lerp(0, 1, (state.handDistance - 1.0) / 2.5);
        material.color.lerpColors(c1.set(state.baseColor), c2.set(state.expandColor), t);
    }

    // 文字状态下减少旋转，方便阅读，其他形状保持旋转
    if (state.shape !== '汉字') {
        particles.rotation.y += state.rotationSpeed;
    } else {
        // 文字时做微弱的摆动
        particles.rotation.y = Math.sin(Date.now() * 0.001) * 0.1;
    }

    renderer.render(scene, camera);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// 启动
initThree();
initGUI();
initMediaPipe();
animate();

</script>
</body>
</html>